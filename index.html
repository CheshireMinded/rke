<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Alliance Dread Calculator - Weekend Kill Tracker</title>
  <link rel="manifest" href="./manifest.json">
  <meta name="theme-color" content="#1a1a2e">
  <meta name="description" content="Track dreadnought kills for alliance players each weekend">
  <meta name="keywords" content="alliance, dreadnought, calculator, gaming, tracker, PWA">
  <meta name="author" content="Alliance Dread Calculator">
  
  <!-- PWA Security and Installation -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="DreadCalc">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="msapplication-TileColor" content="#1a1a2e">
  <meta name="msapplication-tap-highlight" content="no">
  
  <!-- Security Headers -->
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self';">
  <meta http-equiv="X-Content-Type-Options" content="nosniff">
  <meta http-equiv="X-Frame-Options" content="DENY">
  <meta http-equiv="X-XSS-Protection" content="1; mode=block">
  
  <!-- PWA Icons -->
  <link rel="apple-touch-icon" href="./icons/icon-192x192.png">
  <link rel="icon" type="image/png" sizes="192x192" href="./icons/icon-192x192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="./icons/icon-512x512.png">
  <link rel="shortcut icon" href="./icons/icon-192x192.png">
  <style>
    :root {
      /* Light Theme */
      --bg-primary: #ffffff;
      --bg-secondary: #f8fafc;
      --bg-tertiary: #e2e8f0;
      --text-primary: #1e293b;
      --text-secondary: #64748b;
      --accent-primary: #3b82f6;
      --accent-secondary: #10b981;
      --accent-danger: #ef4444;
      --accent-warning: #f59e0b;
      --border-color: #e2e8f0;
      --shadow: rgba(0, 0, 0, 0.1);
      --input-bg: #ffffff;
      --input-border: #d1d5db;
      --card-bg: #ffffff;
      --overlay: rgba(0, 0, 0, 0.5);
    }

    [data-theme="dark"] {
      /* Dark Theme */
      --bg-primary: #1a1a2e;
      --bg-secondary: #16213e;
      --bg-tertiary: #0f3460;
      --text-primary: #ffffff;
      --text-secondary: #cbd5e1;
      --accent-primary: #64b5f6;
      --accent-secondary: #10b981;
      --accent-danger: #ef4444;
      --accent-warning: #f59e0b;
      --border-color: #374151;
      --shadow: rgba(0, 0, 0, 0.3);
      --input-bg: #2a2a3e;
      --input-border: #4b5563;
      --card-bg: #1a1a2e;
      --overlay: rgba(0, 0, 0, 0.7);
    }

    [data-theme="blue"] {
      --bg-primary: #0f172a;
      --bg-secondary: #1e293b;
      --bg-tertiary: #334155;
      --text-primary: #f1f5f9;
      --text-secondary: #cbd5e1;
      --accent-primary: #0ea5e9;
      --accent-secondary: #06b6d4;
      --accent-danger: #f87171;
      --accent-warning: #fbbf24;
      --border-color: #475569;
      --shadow: rgba(15, 23, 42, 0.5);
      --input-bg: #1e293b;
      --input-border: #475569;
      --card-bg: #1e293b;
      --overlay: rgba(15, 23, 42, 0.8);
    }

    [data-theme="green"] {
      --bg-primary: #0f1b0f;
      --bg-secondary: #1a2e1a;
      --bg-tertiary: #2d4a2d;
      --text-primary: #f0fdf4;
      --text-secondary: #bbf7d0;
      --accent-primary: #22c55e;
      --accent-secondary: #16a34a;
      --accent-danger: #ef4444;
      --accent-warning: #eab308;
      --border-color: #365f32;
      --shadow: rgba(15, 27, 15, 0.5);
      --input-bg: #1a2e1a;
      --input-border: #365f32;
      --card-bg: #1a2e1a;
      --overlay: rgba(15, 27, 15, 0.8);
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.6;
      transition: background-color 0.3s ease, color 0.3s ease;
      min-height: 100vh;
      position: relative;
    }

    /* Mobile-first responsive design */
    @media (max-width: 768px) {
      body {
        padding: 10px;
        font-size: 16px; /* Prevent zoom on iOS */
      }
    }

    @media (max-width: 480px) {
      body {
        padding: 8px;
      }
    }

    .container {
      background: var(--bg-secondary);
      padding: 30px;
      border-radius: 15px;
      border: 1px solid var(--border-color);
      box-shadow: 0 4px 6px var(--shadow);
      transition: all 0.3s ease;
      animation: slideInUp 0.6s ease-out;
    }

    @keyframes slideInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    h1 {
      text-align: center;
      color: #64b5f6 !important;
      margin-bottom: 30px;
      font-size: 2.5em;
      font-weight: 700;
      text-shadow: 0 2px 4px var(--shadow);
      animation: fadeInDown 0.8s ease-out;
    }

    @keyframes fadeInDown {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .section {
      background: #1a1a2e !important;
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 20px;
      border: 2px solid #333 !important;
      transition: all 0.3s ease;
      animation: fadeIn 0.5s ease-out;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    .section:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px var(--shadow);
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .section h2 {
      color: #64b5f6 !important;
      margin-top: 0;
      margin-bottom: 15px;
      font-size: 1.5em;
      font-weight: 600;
    }

    .section h3 {
      color: #64b5f6 !important;
      margin-top: 0;
      margin-bottom: 15px;
      font-weight: 600;
    }

    .input-group {
      margin-bottom: 15px;
    }

    label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }

    .flex-row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }

    .flex-row label {
      font-weight: bold;
      white-space: nowrap;
    }

    input[type="number"], input[type="text"], select {
      padding: 12px;
      border: 2px solid var(--input-border);
      border-radius: 8px;
      background: var(--input-bg);
      color: var(--text-primary);
      font-size: 16px; /* Prevent zoom on iOS */
      transition: all 0.3s ease;
      width: 100%;
      box-sizing: border-box;
      min-height: 44px; /* Accessibility: minimum touch target */
      display: block;
    }

    input[type="number"]:focus, input[type="text"]:focus, select:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
      transform: scale(1.02);
    }

    .dread-label {
      font-weight: bold;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 12px;
      white-space: nowrap;
      background: #fbbf24 !important;
      color: #1f2937 !important;
      border: 2px solid #f59e0b !important;
      display: inline-block;
      animation: pulse 2s infinite;
      min-width: 80px;
      text-align: center;
    }

    /* Specific styling for dread input fields */
    .player input[type="number"] {
      background: var(--input-bg) !important;
      border: 2px solid var(--input-border) !important;
      color: var(--text-primary) !important;
      font-weight: bold;
      text-align: center;
    }

    .player input[type="number"]:focus {
      border-color: var(--accent-primary) !important;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2) !important;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    button {
      background: #3b82f6 !important;
      color: white !important;
      border: 2px solid #1d4ed8 !important;
      padding: 12px 24px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      min-height: 44px; /* Accessibility: minimum touch target */
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }

    button:hover::before {
      left: 100%;
    }

    button:hover {
      background: #2563eb !important;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    button:active {
      transform: translateY(0);
      transition: transform 0.1s;
    }

    button:disabled {
      background: #6b7280 !important;
      border-color: #4b5563 !important;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    button.secondary {
      background: #6b7280 !important;
      border-color: #4b5563 !important;
    }

    button.secondary:hover {
      background: #5a6268 !important;
      border-color: #374151 !important;
    }

    button.danger {
      background: #ef4444 !important;
      border-color: #dc2626 !important;
    }

    button.danger:hover {
      background: #dc2626 !important;
      border-color: #b91c1c !important;
    }

    .small {
      font-size: 0.9em;
      color: #ccc;
      margin-top: 10px;
    }

    .player {
      background: #1a1a2e;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #333;
      margin-bottom: 15px;
    }

    .player strong {
      color: #64b5f6;
    }

    .name-input {
      flex: 1;
      min-width: 150px;
    }

    .dread-count {
      margin: 10px 0;
      padding: 8px;
      background: #0f3460;
      border-radius: 4px;
      font-family: monospace;
      font-size: 0.9em;
      text-align: center;
      color: #ffffff !important;
      border: 1px solid #333 !important;
    }

    .dread-count.positive {
      color: #10b981;
    }

    .dread-count.negative {
      color: #ef4444;
    }

    .dread-count.zero {
      color: #6b7280;
    }

    .copy-player-btn {
      background: #10b981 !important;
      border-color: #059669 !important;
      font-size: 12px;
      padding: 6px 12px;
    }

    .copy-player-btn:hover {
      background: #059669 !important;
      border-color: #047857 !important;
    }

    .remove-player-btn {
      background: #ef4444 !important;
      border-color: #dc2626 !important;
      font-size: 12px;
      padding: 6px 12px;
    }

    .remove-player-btn:hover {
      background: #dc2626 !important;
      border-color: #b91c1c !important;
    }

    .coverage-section {
      margin-top: 10px;
      padding: 10px;
      background: #0f3460;
      border-radius: 4px;
      border-left: 3px solid #64b5f6;
    }

    .coverage-section h4 {
      margin: 0 0 10px 0;
      color: #64b5f6;
      font-size: 0.9em;
    }

    .coverage-input {
      width: 100%;
      margin-bottom: 5px;
    }

    .summary-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin: 20px 0;
    }

    .stat-card {
      background: #1a1a2e;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #333;
      text-align: center;
    }

    .stat-card h3 {
      margin: 0 0 10px 0;
      color: #64b5f6;
      font-size: 1em;
    }

    .stat-card .value {
      font-size: 2em;
      font-weight: bold;
      color: #10b981;
    }

    .leaderboard {
      margin-top: 20px;
    }

    .leaderboard-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      background: #1a1a2e;
      border-radius: 4px;
      margin-bottom: 5px;
      border-left: 3px solid #64b5f6;
    }

    .leaderboard-item.top-3 {
      border-left-color: #ffd700;
    }

    .leaderboard-item.top-3:nth-child(1) {
      border-left-color: #ffd700;
    }

    .leaderboard-item.top-3:nth-child(2) {
      border-left-color: #c0c0c0;
    }

    .leaderboard-item.top-3:nth-child(3) {
      border-left-color: #cd7f32;
    }

    .rank {
      font-weight: bold;
      color: #64b5f6;
      min-width: 30px;
    }

    .player-name {
      flex: 1;
      margin: 0 10px;
    }

    .dread-kills {
      font-weight: bold;
      color: #10b981;
    }

    .export-section {
      margin-top: 20px;
      padding: 15px;
      background: #1a1a2e;
      border-radius: 8px;
      border: 1px solid #333;
    }

    .export-buttons {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    @media (max-width: 768px) {
      .flex-row {
        flex-direction: column;
        align-items: stretch;
      }
      
      .flex-row input {
        width: 100%;
      }
      
      .dread-label {
        align-self: flex-start;
      }

      .export-buttons {
        flex-direction: column;
      }

      .export-buttons button {
        width: 100%;
      }
    }

    .complete-checkbox {
      transform: scale(1.5);
      accent-color: #10b981;
      cursor: not-allowed;
    }

    .incomplete-checkbox {
      transform: scale(1.5);
      accent-color: #6b7280;
    }

    .player.complete {
      border-left: 4px solid #10b981;
      background: rgba(16, 185, 129, 0.1);
    }

    .coverage-complete {
      color: var(--accent-secondary);
      font-weight: bold;
    }

    /* Accessibility Features */
    .high-contrast {
      --bg-primary: #000000;
      --bg-secondary: #1a1a1a;
      --bg-tertiary: #333333;
      --text-primary: #ffffff;
      --text-secondary: #cccccc;
      --accent-primary: #00ffff;
      --accent-secondary: #00ff00;
      --accent-danger: #ff0000;
      --accent-warning: #ffff00;
      --border-color: #ffffff;
    }

    .high-contrast button {
      border: 2px solid var(--border-color) !important;
    }

    .high-contrast input, .high-contrast select {
      border: 2px solid var(--border-color) !important;
    }

    .large-text {
      font-size: 1.2em;
    }

    .large-text h1 {
      font-size: 3em;
    }

    .large-text h2 {
      font-size: 2em;
    }

    .large-text button {
      font-size: 18px;
      padding: 16px 32px;
    }

    .large-text input, .large-text select {
      font-size: 18px;
      padding: 16px;
    }

    .reduce-motion * {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
    }

    /* Font Scaling */
    .font-scale-80 { font-size: 0.8em; }
    .font-scale-90 { font-size: 0.9em; }
    .font-scale-100 { font-size: 1em; }
    .font-scale-110 { font-size: 1.1em; }
    .font-scale-120 { font-size: 1.2em; }
    .font-scale-130 { font-size: 1.3em; }
    .font-scale-140 { font-size: 1.4em; }
    .font-scale-150 { font-size: 1.5em; }
    .font-scale-160 { font-size: 1.6em; }
    .font-scale-170 { font-size: 1.7em; }
    .font-scale-180 { font-size: 1.8em; }
    .font-scale-190 { font-size: 1.9em; }
    .font-scale-200 { font-size: 2em; }

    /* Switch Control Support */
    .switch-control {
      outline: 3px solid var(--accent-primary) !important;
      outline-offset: 2px !important;
    }

    .switch-control button:focus,
    .switch-control input:focus,
    .switch-control select:focus {
      outline: 3px solid var(--accent-warning) !important;
      outline-offset: 2px !important;
    }

    /* Screen Reader Support */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    /* Enhanced ARIA support */
    [aria-expanded="true"] {
      background-color: var(--accent-primary);
    }

    [aria-selected="true"] {
      background-color: var(--accent-secondary);
    }

    /* Range slider styling */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      background: transparent;
      cursor: pointer;
    }

    input[type="range"]::-webkit-slider-track {
      background: var(--border-color);
      height: 8px;
      border-radius: 4px;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      background: var(--accent-primary);
      height: 20px;
      width: 20px;
      border-radius: 50%;
      cursor: pointer;
    }

    input[type="range"]::-moz-range-track {
      background: var(--border-color);
      height: 8px;
      border-radius: 4px;
      border: none;
    }

    input[type="range"]::-moz-range-thumb {
      background: var(--accent-primary);
      height: 20px;
      width: 20px;
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }

    /* Mobile Responsive Enhancements */
    @media (max-width: 768px) {
      .container {
        padding: 15px;
        margin: 0;
        border-radius: 0;
        min-height: 100vh;
      }

      .section {
        padding: 15px;
        margin-bottom: 15px;
      }

      h1 {
        font-size: 2em;
        margin-bottom: 20px;
      }

      .flex-row {
        flex-direction: column;
        gap: 8px;
      }

      .flex-row input, .flex-row select {
        width: 100%;
        margin-bottom: 8px;
      }

      /* Special handling for dread input row */
      .player .flex-row {
        flex-direction: row;
        flex-wrap: wrap;
        gap: 8px;
      }

      .player .flex-row .dread-label {
        flex: 0 0 auto;
        min-width: 80px;
      }

      .player .flex-row input[type="number"] {
        flex: 1;
        min-width: 100px;
        margin-bottom: 0;
      }

      .export-buttons {
        flex-direction: column;
        gap: 8px;
      }

      .export-buttons button {
        width: 100%;
        margin-bottom: 8px;
      }

      .summary-stats {
        grid-template-columns: 1fr;
        gap: 10px;
      }

      .player {
        padding: 12px;
      }

      .leaderboard-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 5px;
      }

      /* Theme controls positioning for mobile */
      #themeControls {
        position: fixed;
        top: 10px;
        left: 10px;
        right: 10px;
        justify-content: space-between;
        background: var(--card-bg);
        padding: 8px;
        border-radius: 8px;
        box-shadow: 0 2px 8px var(--shadow);
      }

      #accessibilityPanel {
        top: 60px;
        left: 10px;
        right: 10px;
        min-width: auto;
      }

      /* Install button positioning for mobile */
      #installBtn {
        top: 10px !important;
        right: 10px !important;
        font-size: 12px !important;
        padding: 8px 12px !important;
      }
    }

    @media (max-width: 480px) {
      body {
        padding: 0;
      }

      .container {
        padding: 10px;
        border-radius: 0;
      }

      h1 {
        font-size: 1.8em;
      }

      .section h2 {
        font-size: 1.3em;
      }

      button {
        padding: 14px 20px;
        font-size: 16px;
      }

      .player {
        padding: 10px;
      }

      .dread-count {
        font-size: 1em;
        padding: 10px;
      }
    }

    /* Touch-friendly improvements */
    @media (hover: none) and (pointer: coarse) {
      button:hover {
        transform: none;
        box-shadow: none;
      }

      .section:hover {
        transform: none;
        box-shadow: none;
      }

      input:focus, select:focus {
        transform: none;
      }
    }

    /* High DPI displays */
    @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
      .dread-label {
        border: 1px solid rgba(255, 255, 255, 0.2);
      }
    }

    /* Landscape orientation on mobile */
    @media (max-width: 768px) and (orientation: landscape) {
      .container {
        padding: 10px;
      }

      h1 {
        font-size: 1.5em;
        margin-bottom: 15px;
      }

      .section {
        padding: 10px;
        margin-bottom: 10px;
      }
    }

    /* Focus indicators for keyboard navigation */
    button:focus, input:focus, select:focus {
      outline: 3px solid var(--accent-primary);
      outline-offset: 2px;
    }

    /* Analytics & Charts */
    .analytics-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .chart-section {
      background: #0f1419;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #333;
    }

    .chart-section h3 {
      color: #64b5f6 !important;
      margin-bottom: 15px;
      font-size: 1.1em;
    }

    .chart-section canvas {
      max-width: 100%;
      height: auto;
    }

    /* Achievements */
    .achievements-container {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 20px;
      margin-top: 20px;
    }

    .achievement-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 15px;
    }

    .achievement-card {
      background: #0f1419;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #333;
      text-align: center;
      transition: all 0.3s ease;
    }

    .achievement-card.unlocked {
      border-color: #10b981;
      background: #064e3b;
    }

    .achievement-card.locked {
      opacity: 0.5;
      filter: grayscale(50%);
    }

    .achievement-icon {
      font-size: 2em;
      margin-bottom: 10px;
    }

    .achievement-title {
      font-weight: bold;
      color: #64b5f6 !important;
      margin-bottom: 5px;
    }

    .achievement-description {
      font-size: 0.9em;
      color: #ccc;
    }

    .milestone-tracker {
      background: #0f1419;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #333;
    }

    .milestone-item {
      margin-bottom: 15px;
      padding: 10px;
      background: #1a1a2e;
      border-radius: 6px;
    }

    .milestone-progress {
      width: 100%;
      height: 8px;
      background: #333;
      border-radius: 4px;
      overflow: hidden;
      margin-top: 5px;
    }

    .milestone-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #10b981, #059669);
      transition: width 0.3s ease;
    }

    /* Player Profiles */
    .player-profiles {
      margin-top: 20px;
    }

    .profile-selector {
      margin-bottom: 20px;
    }

    .profile-selector select {
      width: 100%;
      max-width: 300px;
      padding: 10px;
      border-radius: 6px;
      border: 1px solid #333;
      background: #1a1a2e;
      color: white;
    }

    .profile-details {
      background: #0f1419;
      padding: 20px;
      border-radius: 8px;
      border: 1px solid #333;
    }

    .profile-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      margin-top: 15px;
    }

    .profile-stat {
      text-align: center;
      padding: 10px;
      background: #1a1a2e;
      border-radius: 6px;
    }

    .profile-stat-value {
      font-size: 1.5em;
      font-weight: bold;
      color: #10b981;
    }

    .profile-stat-label {
      font-size: 0.9em;
      color: #ccc;
    }

    /* Goals & Targets */
    .goals-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-top: 20px;
    }

    .goal-settings, .team-goals {
      background: #0f1419;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #333;
    }

    .custom-target-item {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
      padding: 10px;
      background: #1a1a2e;
      border-radius: 6px;
    }

    .custom-target-item input {
      flex: 1;
      padding: 5px;
      border: 1px solid #333;
      border-radius: 4px;
      background: #0f1419;
      color: white;
    }

    .goal-input {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 10px;
    }

    .goal-progress {
      font-weight: bold;
      color: #10b981;
    }

    /* Notifications */
    .notifications-container {
      margin-top: 20px;
    }

    .notification-settings {
      background: #0f1419;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #333;
    }

    .setting-item {
      margin-bottom: 15px;
    }

    .setting-item label {
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
    }

    .setting-item input[type="checkbox"] {
      transform: scale(1.2);
    }

    /* Cloud Backup */
    .backup-container {
      margin-top: 20px;
    }

    .backup-actions {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .backup-status {
      background: #0f1419;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #333;
    }

    .backup-status p {
      margin: 5px 0;
    }

    /* Voice Input */
    .voice-container {
      margin-top: 20px;
    }

    .voice-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }

    .voice-status {
      background: #0f1419;
      padding: 10px;
      border-radius: 6px;
      border: 1px solid #333;
      margin-bottom: 10px;
      color: #ccc;
    }

    .voice-results {
      background: #1a1a2e;
      padding: 15px;
      border-radius: 6px;
      border: 1px solid #333;
      min-height: 50px;
    }

    .voice-recording {
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Export Options */
    .export-options {
      background: #0f1419;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #333;
      margin-top: 15px;
    }

    .export-options h3 {
      color: #64b5f6 !important;
      margin-bottom: 15px;
    }

    .export-option {
      margin-bottom: 10px;
    }

    .export-option label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
    }

    .export-option input[type="checkbox"] {
      transform: scale(1.2);
    }

    /* Skip to content link for screen readers */
    .skip-link {
      position: absolute;
      top: -40px;
      left: 6px;
      background: var(--accent-primary);
      color: white;
      padding: 8px;
      text-decoration: none;
      border-radius: 4px;
      z-index: 10000;
    }

    .skip-link:focus {
      top: 6px;
    }
  </style>
</head>
<body>

    <!-- Skip to content link for screen readers -->
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <!-- Theme Toggle and Accessibility Controls -->
    <div id="themeControls" style="position: fixed; top: 20px; left: 20px; z-index: 1000; display: flex; gap: 10px; flex-wrap: wrap;">
      <button id="themeToggle" aria-label="Toggle theme" style="padding: 8px 12px; font-size: 14px; min-height: 36px; background: #3b82f6 !important; color: white !important; border: 2px solid #1d4ed8 !important;">
        üåô Dark
      </button>
      <select id="colorScheme" aria-label="Choose color scheme" style="padding: 8px; font-size: 14px; min-height: 36px; background: #f8fafc !important; color: #1e293b !important; border: 2px solid #d1d5db !important;">
        <option value="dark">Dark Theme</option>
        <option value="light">Light Theme</option>
        <option value="blue">Blue Theme</option>
        <option value="green">Green Theme</option>
      </select>
      <button id="accessibilityToggle" aria-label="Toggle accessibility features" style="padding: 8px 12px; font-size: 14px; min-height: 36px; background: #10b981 !important; color: white !important; border: 2px solid #059669 !important;">
        ‚ôø A11y
      </button>
    </div>

    <!-- Accessibility Panel -->
    <div id="accessibilityPanel" style="display: none; position: fixed; top: 80px; left: 20px; background: var(--card-bg); border: 2px solid var(--border-color); border-radius: 8px; padding: 15px; z-index: 1000; min-width: 280px; box-shadow: 0 4px 12px var(--shadow);">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
        <h3 style="margin: 0; color: var(--accent-primary);">Accessibility Options</h3>
        <button id="closeAccessibilityPanel" style="background: #ef4444 !important; color: white !important; border: 2px solid #dc2626 !important; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 12px;" aria-label="Close accessibility panel">‚úï</button>
      </div>
      
      <div style="margin-bottom: 15px;">
        <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
          <input type="checkbox" id="highContrast" style="transform: scale(1.2);">
          <span>High Contrast Mode</span>
        </label>
        <div style="font-size: 0.8em; color: var(--text-secondary); margin-left: 24px;">Enhanced contrast for better visibility</div>
      </div>
      
      <div style="margin-bottom: 15px;">
        <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
          <input type="checkbox" id="largeText" style="transform: scale(1.2);">
          <span>Large Text Mode</span>
        </label>
        <div style="font-size: 0.8em; color: var(--text-secondary); margin-left: 24px;">Increases text size by 20%</div>
      </div>
      
      <div style="margin-bottom: 15px;">
        <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
          <input type="checkbox" id="reduceMotion" style="transform: scale(1.2);">
          <span>Reduce Motion</span>
        </label>
        <div style="font-size: 0.8em; color: var(--text-secondary); margin-left: 24px;">Disables animations and transitions</div>
      </div>
      
      <div style="margin-bottom: 15px;">
        <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
          <input type="checkbox" id="hapticFeedback" style="transform: scale(1.2);">
          <span>Haptic Feedback</span>
        </label>
        <div style="font-size: 0.8em; color: var(--text-secondary); margin-left: 24px;">Vibration feedback for interactions</div>
      </div>
      
      <div style="margin-bottom: 15px;">
        <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
          <input type="checkbox" id="switchControl" style="transform: scale(1.2);">
          <span>Switch Control Support</span>
        </label>
        <div style="font-size: 0.8em; color: var(--text-secondary); margin-left: 24px;">Enhanced keyboard navigation</div>
      </div>
      
      <div style="margin-bottom: 15px;">
        <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
          <input type="checkbox" id="screenReader" style="transform: scale(1.2);">
          <span>Screen Reader Support</span>
        </label>
        <div style="font-size: 0.8em; color: var(--text-secondary); margin-left: 24px;">Enhanced ARIA labels and descriptions</div>
      </div>
      
      <div style="border-top: 1px solid var(--border-color); padding-top: 15px;">
        <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
          <span>Font Scale:</span>
          <input type="range" id="fontScale" min="0.8" max="2.0" step="0.1" value="1.0" style="flex: 1; margin: 0 8px;">
          <span id="fontScaleValue">100%</span>
        </label>
        <div style="font-size: 0.8em; color: var(--text-secondary);">Adjust text size from 80% to 200%</div>
      </div>
    </div>

    <div class="container" id="main-content" role="main" aria-label="Alliance Dread Calculator">
    <h1>‚öîÔ∏è Alliance Dread Calculator</h1>
    <p style="text-align: center; color: var(--text-secondary); margin-bottom: 10px;">Track weekend dreadnought kills for your alliance players</p>
    <p style="text-align: center; color: var(--accent-primary); font-weight: bold; margin-bottom: 30px;" id="currentWeekDisplay" aria-live="polite">Current Week: Loading...</p>

    <div class="section">
      <h2>Alliance Target</h2>
      <div class="flex-row">
        <label for="defaultTarget">Default Dreads Target per Player:</label>
        <input type="number" id="defaultTarget" value="50" min="0" inputmode="numeric" 
               onchange="dreadCalculator.updateTarget(parseInt(this.value) || 0)" 
               style="width: 120px; font-size: 16px; font-weight: bold;" />
        <span class="dread-label">dreads</span>
      </div>
      <p class="small">Players who reach this target will be automatically marked as complete. Coverage players will also be marked complete when their covered bases reach the target.</p>
    </div>

    <div class="section" role="region" aria-label="Player Dread Tracking">
      <div class="flex-row" style="justify-content:space-between; gap:10px;">
        <h2>Player Dread Tracking</h2>
        <div class="flex-row" style="gap:6px;">
          <button id="addBtn" aria-label="Add new player">Add Player</button>
          <button class="secondary" id="removeBtn" disabled aria-label="Remove last player">Remove Last</button>
          <button class="secondary" id="clearAllBtn" aria-label="Clear all players">Clear All</button>
        </div>
      </div>
      <div id="playersContainer" role="list" aria-label="List of players"></div>
    </div>

    <div class="section" id="summarySection" style="display: none;">
      <h2>Weekend Summary</h2>
      <div class="summary-stats">
        <div class="stat-card">
          <h3>Total Players</h3>
          <div class="value" id="totalPlayers">0</div>
        </div>
        <div class="stat-card">
          <h3>Total Dreads Killed</h3>
          <div class="value" id="totalDreads">0</div>
        </div>
        <div class="stat-card">
          <h3>Average per Player</h3>
          <div class="value" id="averageDreads">0</div>
        </div>
        <div class="stat-card">
          <h3>Top Performer</h3>
          <div class="value" id="topPerformer">-</div>
        </div>
      </div>
    </div>

    <div class="section" id="leaderboardSection" style="display: none;">
      <h2>Leaderboard</h2>
      <div class="leaderboard" id="leaderboard"></div>
    </div>

    <div class="section">
      <h2>Weekly Management</h2>
      <div class="export-section">
        <div class="export-buttons">
          <button id="saveWeekBtn">Save Current Week</button>
          <button id="loadWeekBtn">Load Previous Week</button>
          <button id="newWeekBtn">Start New Week</button>
          <button id="viewHistoryBtn">View History</button>
        </div>
        <p class="small">Save your current week's data and load previous weeks for comparison.</p>
      </div>
    </div>

    <div class="section" id="historySection" style="display: none;">
      <h2>Weekly History</h2>
      <div id="weekSelector" style="margin-bottom: 15px;">
        <label for="weekSelect">Select Week:</label>
        <select id="weekSelect" onchange="dreadCalculator.loadSelectedWeek()">
          <option value="">Choose a week...</option>
        </select>
        <button id="deleteWeekBtn" class="danger" onclick="dreadCalculator.deleteSelectedWeek()" style="margin-left: 10px;">Delete Week</button>
      </div>
      
      <div id="copyPlayersSection" style="margin-bottom: 15px; padding: 15px; background: #1a1a2e; border-radius: 8px; border: 1px solid #333;">
        <h3 style="color: #64b5f6; margin-top: 0;">Copy Players from Another Week</h3>
        <div class="flex-row" style="margin-bottom: 10px;">
          <label for="copyFromWeek">Copy from:</label>
          <select id="copyFromWeek" style="flex: 1; margin-right: 10px;">
            <option value="">Select week to copy from...</option>
          </select>
          <button id="copyPlayersBtn" onclick="dreadCalculator.copyPlayersFromWeek()">Copy Player Names</button>
        </div>
        <p class="small">This will copy player names and coverage settings from the selected week to your current week. Dread counts will be reset to 0.</p>
      </div>
      
      <div id="weekComparison"></div>
    </div>

    <div class="section">
      <h2>üìä Analytics & Trends</h2>
      <div class="analytics-container">
        <div class="chart-section">
          <h3>Weekly Performance Trends</h3>
          <canvas id="weeklyTrendChart" width="400" height="200"></canvas>
        </div>
        <div class="chart-section">
          <h3>Player Performance Comparison</h3>
          <canvas id="playerComparisonChart" width="400" height="200"></canvas>
        </div>
        <div class="chart-section">
          <h3>Completion Rate Over Time</h3>
          <canvas id="completionRateChart" width="400" height="200"></canvas>
        </div>
        <div class="chart-section">
          <h3>Top Performers This Month</h3>
          <canvas id="topPerformersChart" width="400" height="200"></canvas>
        </div>
      </div>
    </div>

    <div class="section">
      <h2>üèÜ Achievements & Milestones</h2>
      <div class="achievements-container">
        <div class="achievement-grid" id="achievementGrid">
          <!-- Achievements will be populated here -->
        </div>
        <div class="milestone-tracker">
          <h3>Current Milestones</h3>
          <div id="milestoneProgress"></div>
        </div>
      </div>
    </div>

    <div class="section">
      <h2>üë• Player Profiles</h2>
      <div class="player-profiles">
        <div class="profile-selector">
          <select id="playerProfileSelect" onchange="dreadCalculator.showPlayerProfile(this.value)">
            <option value="">Select a player...</option>
          </select>
        </div>
        <div id="playerProfileDetails" class="profile-details" style="display: none;">
          <!-- Player profile details will be shown here -->
        </div>
      </div>
    </div>

    <div class="section">
      <h2>üéØ Custom Goals & Targets</h2>
      <div class="goals-container">
        <div class="goal-settings">
          <h3>Individual Player Targets</h3>
          <div id="customTargetsList"></div>
          <button id="addCustomTargetBtn" onclick="dreadCalculator.addCustomTarget()">Add Custom Target</button>
        </div>
        <div class="team-goals">
          <h3>Team Goals</h3>
          <div class="goal-input">
            <label for="teamGoal">Total Alliance Target:</label>
            <input type="number" id="teamGoal" placeholder="e.g., 1000" onchange="dreadCalculator.setTeamGoal(this.value)">
            <span class="goal-progress" id="teamGoalProgress">0%</span>
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <h2>üîî Smart Notifications</h2>
      <div class="notifications-container">
        <div class="notification-settings">
          <h3>Notification Preferences</h3>
          <div class="setting-item">
            <label>
              <input type="checkbox" id="weeklyReminders" onchange="dreadCalculator.toggleNotification('weekly', this.checked)">
              Weekly reminder notifications
            </label>
          </div>
          <div class="setting-item">
            <label>
              <input type="checkbox" id="deadlineAlerts" onchange="dreadCalculator.toggleNotification('deadline', this.checked)">
              Weekend deadline alerts
            </label>
          </div>
          <div class="setting-item">
            <label>
              <input type="checkbox" id="achievementAlerts" onchange="dreadCalculator.toggleNotification('achievement', this.checked)">
              Achievement notifications
            </label>
          </div>
          <button id="testNotificationBtn" onclick="dreadCalculator.testNotification()">Test Notification</button>
        </div>
      </div>
    </div>

    <div class="section">
      <h2>‚òÅÔ∏è Cloud Backup & Sync</h2>
      <div class="backup-container">
        <div class="backup-actions">
          <button id="backupToCloudBtn" onclick="dreadCalculator.backupToCloud()">üì§ Backup to Cloud</button>
          <button id="restoreFromCloudBtn" onclick="dreadCalculator.restoreFromCloud()">üì• Restore from Cloud</button>
          <button id="syncDataBtn" onclick="dreadCalculator.syncData()">üîÑ Sync Data</button>
        </div>
        <div class="backup-status" id="backupStatus">
          <p>Last backup: <span id="lastBackupTime">Never</span></p>
          <p>Sync status: <span id="syncStatus">Not connected</span></p>
        </div>
      </div>
    </div>

    <div class="section">
      <h2>üé§ Voice Input</h2>
      <div class="voice-container">
        <div class="voice-controls">
          <button id="voiceInputBtn" onclick="dreadCalculator.startVoiceInput()">üé§ Start Voice Input</button>
          <button id="stopVoiceBtn" onclick="dreadCalculator.stopVoiceInput()" style="display: none;">‚èπÔ∏è Stop</button>
        </div>
        <div class="voice-status" id="voiceStatus">Click the microphone to start voice input</div>
        <div class="voice-results" id="voiceResults"></div>
      </div>
    </div>

    <div class="section">
      <h2>Export & Share</h2>
      <div class="export-section">
        <div class="export-buttons">
          <button id="exportJsonBtn">üìÑ Export as JSON</button>
          <button id="exportCsvBtn">üìä Export as CSV</button>
          <button id="exportPdfBtn" onclick="dreadCalculator.exportPdf()">üìã Export as PDF Report</button>
          <button id="exportExcelBtn" onclick="dreadCalculator.exportExcel()">üìà Export as Excel</button>
          <button id="copyResultsBtn">üìã Copy Results</button>
          <button id="importDataBtn">üì• Import Data</button>
          <input type="file" id="importFile" accept=".json,.csv,.xlsx" style="display: none;">
        </div>
        <div class="export-options">
          <h3>Report Options</h3>
          <div class="export-option">
            <label>
              <input type="checkbox" id="includeCharts" checked> Include charts in PDF
            </label>
          </div>
          <div class="export-option">
            <label>
              <input type="checkbox" id="includeHistory" checked> Include weekly history
            </label>
          </div>
          <div class="export-option">
            <label>
              <input type="checkbox" id="includeAchievements" checked> Include achievements
            </label>
          </div>
        </div>
        <p class="small">Export your data to share with alliance members or backup your results. PDF reports include charts and detailed analysis.</p>
      </div>
    </div>
  </div>

  <!-- Chart.js for data visualization -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  
  <!-- PDF generation library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  
  <!-- Excel export library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  
  <script>
    class DreadCalculator {
      constructor() {
        this.players = [];
        this.playerCounter = 1;
        this.defaultTarget = 50;
        this.weeklyData = {};
        this.currentWeek = this.getCurrentWeek();
        this.achievements = [];
        this.customTargets = {};
        this.teamGoal = 0;
        this.notificationSettings = {
          weekly: false,
          deadline: false,
          achievement: false
        };
        this.charts = {};
        this.voiceRecognition = null;
        this.isRecording = false;
        this.cloudData = null;
        this.lastBackupTime = null;
        this.syncStatus = 'Not connected';
        this.achievementDefinitions = this.initializeAchievements();
        this.milestones = this.initializeMilestones();
        this.init();
      }

      init() {
        this.bindEvents();
        this.addPlayer(); // Add first player by default
      }

      bindEvents() {
        document.getElementById('addBtn').addEventListener('click', () => this.addPlayer());
        document.getElementById('removeBtn').addEventListener('click', () => this.removeLastPlayer());
        document.getElementById('clearAllBtn').addEventListener('click', () => this.clearAllPlayers());
        document.getElementById('exportJsonBtn').addEventListener('click', () => this.exportJson());
        document.getElementById('exportCsvBtn').addEventListener('click', () => this.exportCsv());
        document.getElementById('copyResultsBtn').addEventListener('click', () => this.copyResults());
        document.getElementById('importDataBtn').addEventListener('click', () => document.getElementById('importFile').click());
        document.getElementById('importFile').addEventListener('change', (e) => this.importData(e));
        
        // Weekly management events
        document.getElementById('saveWeekBtn').addEventListener('click', () => this.saveCurrentWeek());
        document.getElementById('loadWeekBtn').addEventListener('click', () => this.showWeekSelector());
        document.getElementById('newWeekBtn').addEventListener('click', () => this.startNewWeek());
        document.getElementById('viewHistoryBtn').addEventListener('click', () => this.toggleHistoryView());
        
        // Load saved data on startup
        this.loadSavedData();
      }

      addPlayer() {
        const playerId = `player_${this.playerCounter++}`;
        const player = {
          id: playerId,
          name: `Player ${this.playerCounter - 1}`,
          startDreads: 0,
          endDreads: 0,
          coverage: []
        };
        
        this.players.push(player);
        this.renderPlayer(player);
        this.updateUI();
      }

      removeLastPlayer() {
        if (this.players.length > 0) {
          this.players.pop();
          this.updateUI();
        }
      }

      clearAllPlayers() {
        if (confirm('Are you sure you want to clear all players?')) {
          this.players = [];
          this.playerCounter = 1;
          this.updateUI();
        }
      }

      renderPlayer(player) {
        const container = document.getElementById('playersContainer');
        const playerDiv = document.createElement('div');
        playerDiv.className = 'player';
        playerDiv.id = player.id;
        
        const isComplete = this.isPlayerComplete(player);
        const checkboxClass = isComplete ? 'complete-checkbox' : 'incomplete-checkbox';
        const checkboxDisabled = isComplete ? 'disabled' : '';
        
        playerDiv.innerHTML = `
          <div class="flex-row" role="listitem">
            <input type="checkbox" class="${checkboxClass}" ${checkboxDisabled} 
                   id="checkbox_${player.id}" onchange="dreadCalculator.togglePlayerComplete('${player.id}', this.checked)"
                   aria-label="Player completion status for ${player.name}">
            <input type="text" class="name-input" placeholder="Player name" value="${player.name}" 
                   onchange="dreadCalculator.updatePlayerName('${player.id}', this.value)"
                   aria-label="Player name for ${player.name}">
            <button class="copy-player-btn" onclick="dreadCalculator.copyPlayer('${player.id}')" 
                    aria-label="Copy player data for ${player.name}">Copy</button>
            <button class="remove-player-btn" onclick="dreadCalculator.removePlayer('${player.id}')" 
                    aria-label="Remove player ${player.name}">Remove</button>
          </div>
          
          <div class="flex-row" style="margin-top: 10px; gap: 8px; align-items: center;">
            <span class="dread-label">Start Dreads</span>
            <input type="number" placeholder="Starting dread count" value="${player.startDreads}" 
                   onchange="dreadCalculator.updatePlayerStart('${player.id}', parseInt(this.value) || 0)"
                   aria-label="Starting dread count for ${player.name}"
                   style="flex: 1; min-width: 120px;">
            <span class="dread-label">End Dreads</span>
            <input type="number" placeholder="Ending dread count" value="${player.endDreads}" 
                   onchange="dreadCalculator.updatePlayerEnd('${player.id}', parseInt(this.value) || 0)"
                   aria-label="Ending dread count for ${player.name}"
                   style="flex: 1; min-width: 120px;">
          </div>
          
          <div class="dread-count" id="count_${player.id}">
            Dreads Killed: <span id="kills_${player.id}">0</span>
          </div>
          
          <div class="coverage-section">
            <h4>Base Coverage (Optional)</h4>
            <input type="text" class="coverage-input" placeholder="Player covering this base (e.g., Player 2)" 
                   value="${player.coverage.join(', ')}" 
                   onchange="dreadCalculator.updateCoverage('${player.id}', this.value)">
            <div class="small">Enter names of players who are covering this base, separated by commas</div>
          </div>
        `;
        
        container.appendChild(playerDiv);
        this.updatePlayerKills(player.id);
      }

      updatePlayerName(playerId, name) {
        const player = this.players.find(p => p.id === playerId);
        if (player) {
          player.name = name;
          this.updateUI();
        }
      }

      updatePlayerStart(playerId, startDreads) {
        const player = this.players.find(p => p.id === playerId);
        if (player) {
          player.startDreads = startDreads;
          this.updatePlayerKills(playerId);
          this.updatePlayerCompletion(player);
          this.updateUI();
        }
      }

      updatePlayerEnd(playerId, endDreads) {
        const player = this.players.find(p => p.id === playerId);
        if (player) {
          player.endDreads = endDreads;
          this.updatePlayerKills(playerId);
          this.updatePlayerCompletion(player);
          this.updateUI();
        }
      }

      updateCoverage(playerId, coverageText) {
        const player = this.players.find(p => p.id === playerId);
        if (player) {
          player.coverage = coverageText.split(',').map(name => name.trim()).filter(name => name);
          this.updatePlayerCompletion(player);
          this.updateUI();
        }
      }

      updatePlayerKills(playerId) {
        const player = this.players.find(p => p.id === playerId);
        if (player) {
          const kills = player.endDreads - player.startDreads;
          const killsElement = document.getElementById(`kills_${playerId}`);
          const countElement = document.getElementById(`count_${playerId}`);
          
          if (killsElement) {
            killsElement.textContent = kills;
            killsElement.className = kills > 0 ? 'positive' : kills < 0 ? 'negative' : 'zero';
          }
          
          if (countElement) {
            countElement.className = `dread-count ${kills > 0 ? 'positive' : kills < 0 ? 'negative' : 'zero'}`;
          }
        }
      }

      removePlayer(playerId) {
        this.players = this.players.filter(p => p.id !== playerId);
        const playerElement = document.getElementById(playerId);
        if (playerElement) {
          playerElement.remove();
        }
        this.updateUI();
      }

      copyPlayer(playerId) {
        const player = this.players.find(p => p.id === playerId);
        if (player) {
          const playerData = {
            name: player.name,
            startDreads: player.startDreads,
            endDreads: player.endDreads,
            coverage: player.coverage
          };
          
          navigator.clipboard.writeText(JSON.stringify(playerData, null, 2)).then(() => {
            alert('Player data copied to clipboard!');
          });
        }
      }

      updateTarget(newTarget) {
        this.defaultTarget = newTarget;
        this.updateAllPlayerCompletions();
        this.updateUI();
      }

      isPlayerComplete(player) {
        const dreadsKilled = player.endDreads - player.startDreads;
        return dreadsKilled >= this.defaultTarget;
      }

      isPlayerCompleteByCoverage(player) {
        // Check if any of the players this player is covering have reached the target
        return player.coverage.some(coveredPlayerName => {
          const coveredPlayer = this.players.find(p => p.name === coveredPlayerName);
          return coveredPlayer && this.isPlayerComplete(coveredPlayer);
        });
      }

      updateAllPlayerCompletions() {
        this.players.forEach(player => {
          this.updatePlayerCompletion(player);
        });
      }

      updatePlayerCompletion(player) {
        const isComplete = this.isPlayerComplete(player) || this.isPlayerCompleteByCoverage(player);
        const checkbox = document.getElementById(`checkbox_${player.id}`);
        const playerElement = document.getElementById(player.id);
        
        if (checkbox) {
          checkbox.checked = isComplete;
          checkbox.disabled = isComplete;
          checkbox.className = isComplete ? 'complete-checkbox' : 'incomplete-checkbox';
        }
        
        if (playerElement) {
          if (isComplete) {
            playerElement.classList.add('complete');
          } else {
            playerElement.classList.remove('complete');
          }
        }
      }

      togglePlayerComplete(playerId, checked) {
        // This method is for manual toggling, but we'll prevent it if auto-complete
        const player = this.players.find(p => p.id === playerId);
        if (player && !this.isPlayerComplete(player) && !this.isPlayerCompleteByCoverage(player)) {
          // Only allow manual toggle if not auto-complete
          console.log(`Player ${player.name} manually ${checked ? 'completed' : 'uncompleted'}`);
        }
      }

      updateUI() {
        this.updateRemoveButton();
        this.updateSummary();
        this.updateLeaderboard();
        this.updateAllPlayerCompletions();
        this.autoSave(); // Auto-save on any UI update
      }

      updateRemoveButton() {
        const removeBtn = document.getElementById('removeBtn');
        removeBtn.disabled = this.players.length <= 1;
      }

      updateSummary() {
        const totalPlayers = this.players.length;
        const totalDreads = this.players.reduce((sum, player) => sum + (player.endDreads - player.startDreads), 0);
        const averageDreads = totalPlayers > 0 ? Math.round(totalDreads / totalPlayers) : 0;
        const completedPlayers = this.players.filter(player => 
          this.isPlayerComplete(player) || this.isPlayerCompleteByCoverage(player)
        ).length;
        const topPlayer = this.players.reduce((top, player) => {
          const kills = player.endDreads - player.startDreads;
          const topKills = top.endDreads - top.startDreads;
          return kills > topKills ? player : top;
        }, this.players[0]);

        document.getElementById('totalPlayers').textContent = totalPlayers;
        document.getElementById('totalDreads').textContent = totalDreads;
        document.getElementById('averageDreads').textContent = averageDreads;
        document.getElementById('topPerformer').textContent = topPlayer ? `${topPlayer.name} (${topPlayer.endDreads - topPlayer.startDreads})` : '-';

        // Update the summary cards to show completion stats
        const totalPlayersCard = document.querySelector('.stat-card h3');
        if (totalPlayersCard) {
          totalPlayersCard.textContent = `Total Players (${completedPlayers}/${totalPlayers} Complete)`;
        }

        const summarySection = document.getElementById('summarySection');
        const leaderboardSection = document.getElementById('leaderboardSection');
        
        if (totalPlayers > 0) {
          summarySection.style.display = 'block';
          leaderboardSection.style.display = 'block';
        } else {
          summarySection.style.display = 'none';
          leaderboardSection.style.display = 'none';
        }
      }

      updateLeaderboard() {
        const leaderboard = document.getElementById('leaderboard');
        leaderboard.innerHTML = '';

        const sortedPlayers = [...this.players].sort((a, b) => {
          const killsA = a.endDreads - a.startDreads;
          const killsB = b.endDreads - b.startDreads;
          return killsB - killsA;
        });

        sortedPlayers.forEach((player, index) => {
          const kills = player.endDreads - player.startDreads;
          const isComplete = this.isPlayerComplete(player) || this.isPlayerCompleteByCoverage(player);
          const item = document.createElement('div');
          item.className = `leaderboard-item ${index < 3 ? 'top-3' : ''} ${isComplete ? 'complete' : ''}`;
          
          const completionIcon = isComplete ? '‚úÖ ' : '';
          const coverageNote = this.isPlayerCompleteByCoverage(player) && !this.isPlayerComplete(player) ? ' (via coverage)' : '';
          
          item.innerHTML = `
            <div class="rank">#${index + 1}</div>
            <div class="player-name">${completionIcon}${player.name}${coverageNote}</div>
            <div class="dread-kills">${kills} dreads</div>
          `;
          
          leaderboard.appendChild(item);
        });
      }

      exportJson() {
        const data = {
          players: this.players,
          exportDate: new Date().toISOString(),
          totalDreads: this.players.reduce((sum, player) => sum + (player.endDreads - player.startDreads), 0)
        };
        
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `dread-calculator-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
      }

      exportCsv() {
        const headers = ['Player Name', 'Start Dreads', 'End Dreads', 'Dreads Killed', 'Coverage'];
        const rows = this.players.map(player => [
          player.name,
          player.startDreads,
          player.endDreads,
          player.endDreads - player.startDreads,
          player.coverage.join('; ')
        ]);
        
        const csvContent = [headers, ...rows]
          .map(row => row.map(cell => `"${cell}"`).join(','))
          .join('\n');
        
        const blob = new Blob([csvContent], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `dread-calculator-${new Date().toISOString().split('T')[0]}.csv`;
        a.click();
        URL.revokeObjectURL(url);
      }

      copyResults() {
        const results = this.players.map(player => {
          const kills = player.endDreads - player.startDreads;
          return `${player.name}: ${kills} dreads killed (${player.startDreads} ‚Üí ${player.endDreads})`;
        }).join('\n');
        
        const totalDreads = this.players.reduce((sum, player) => sum + (player.endDreads - player.startDreads), 0);
        const summary = `Alliance Dread Summary\nTotal Dreads Killed: ${totalDreads}\n\nPlayer Results:\n${results}`;
        
        navigator.clipboard.writeText(summary).then(() => {
          alert('Results copied to clipboard!');
        });
      }

      importData(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = JSON.parse(e.target.result);
            if (data.players && Array.isArray(data.players)) {
              this.players = data.players;
              this.playerCounter = Math.max(...this.players.map(p => parseInt(p.id.split('_')[1]) || 0)) + 1;
              this.renderAllPlayers();
              this.updateUI();
              alert('Data imported successfully!');
            } else {
              throw new Error('Invalid data format');
            }
          } catch (error) {
            alert('Error importing data: ' + error.message);
          }
        };
        reader.readAsText(file);
      }

      renderAllPlayers() {
        const container = document.getElementById('playersContainer');
        container.innerHTML = '';
        this.players.forEach(player => this.renderPlayer(player));
      }

      // Weekly Management Methods
      getCurrentWeek() {
        const now = new Date();
        const startOfYear = new Date(now.getFullYear(), 0, 1);
        const days = Math.floor((now - startOfYear) / (24 * 60 * 60 * 1000));
        const weekNumber = Math.ceil((days + startOfYear.getDay() + 1) / 7);
        return `${now.getFullYear()}-W${weekNumber.toString().padStart(2, '0')}`;
      }

      saveCurrentWeek() {
        const weekData = {
          week: this.currentWeek,
          date: new Date().toISOString(),
          target: this.defaultTarget,
          players: this.players.map(player => ({
            ...player,
            dreadsKilled: player.endDreads - player.startDreads,
            isComplete: this.isPlayerComplete(player) || this.isPlayerCompleteByCoverage(player)
          })),
          summary: {
            totalPlayers: this.players.length,
            totalDreads: this.players.reduce((sum, player) => sum + (player.endDreads - player.startDreads), 0),
            completedPlayers: this.players.filter(player => 
              this.isPlayerComplete(player) || this.isPlayerCompleteByCoverage(player)
            ).length
          }
        };

        this.weeklyData[this.currentWeek] = weekData;
        this.saveToLocalStorage();
        
        alert(`Week ${this.currentWeek} saved successfully!`);
        this.updateWeekSelector();
      }

      loadSelectedWeek() {
        const weekSelect = document.getElementById('weekSelect');
        const selectedWeek = weekSelect.value;
        
        if (selectedWeek && this.weeklyData[selectedWeek]) {
          const weekData = this.weeklyData[selectedWeek];
          this.loadWeekData(weekData);
          this.currentWeek = selectedWeek;
          alert(`Loaded week ${selectedWeek}`);
        }
      }

      loadWeekData(weekData) {
        // Clear current players
        this.players = [];
        this.playerCounter = 1;
        
        // Load week data
        this.defaultTarget = weekData.target;
        document.getElementById('defaultTarget').value = this.defaultTarget;
        
        // Restore players
        weekData.players.forEach(playerData => {
          const player = {
            id: `player_${this.playerCounter++}`,
            name: playerData.name,
            startDreads: playerData.startDreads,
            endDreads: playerData.endDreads,
            coverage: playerData.coverage || []
          };
          this.players.push(player);
        });
        
        this.renderAllPlayers();
        this.updateUI();
      }

      startNewWeek() {
        if (confirm('Start a new week? This will clear current data and create a new week entry.')) {
          // Save current week if there's data
          if (this.players.length > 0 && this.players.some(p => p.startDreads > 0 || p.endDreads > 0)) {
            this.saveCurrentWeek();
          }
          
          // Clear current data
          this.players = [];
          this.playerCounter = 1;
          this.currentWeek = this.getCurrentWeek();
          
          // Reset to default target
          this.defaultTarget = 50;
          document.getElementById('defaultTarget').value = this.defaultTarget;
          
          // Add one empty player
          this.addPlayer();
          this.updateUI();
          
          alert(`Started new week: ${this.currentWeek}`);
        }
      }

      showWeekSelector() {
        this.updateWeekSelector();
        document.getElementById('historySection').style.display = 'block';
        document.getElementById('weekSelector').scrollIntoView({ behavior: 'smooth' });
      }

      toggleHistoryView() {
        const historySection = document.getElementById('historySection');
        if (historySection.style.display === 'none') {
          this.updateWeekSelector();
          historySection.style.display = 'block';
        } else {
          historySection.style.display = 'none';
        }
      }

      updateWeekSelector() {
        const weekSelect = document.getElementById('weekSelect');
        const copyFromWeek = document.getElementById('copyFromWeek');
        
        weekSelect.innerHTML = '<option value="">Choose a week...</option>';
        copyFromWeek.innerHTML = '<option value="">Select week to copy from...</option>';
        
        const weeks = Object.keys(this.weeklyData).sort().reverse();
        weeks.forEach(week => {
          const option = document.createElement('option');
          option.value = week;
          option.textContent = `${week} (${this.weeklyData[week].summary.completedPlayers}/${this.weeklyData[week].summary.totalPlayers} complete)`;
          weekSelect.appendChild(option);
          
          // Add to copy from selector (exclude current week)
          if (week !== this.currentWeek) {
            const copyOption = document.createElement('option');
            copyOption.value = week;
            copyOption.textContent = `${week} (${this.weeklyData[week].summary.completedPlayers}/${this.weeklyData[week].summary.totalPlayers} complete)`;
            copyFromWeek.appendChild(copyOption);
          }
        });
      }

      deleteSelectedWeek() {
        const weekSelect = document.getElementById('weekSelect');
        const selectedWeek = weekSelect.value;
        
        if (selectedWeek && confirm(`Delete week ${selectedWeek}? This cannot be undone.`)) {
          delete this.weeklyData[selectedWeek];
          this.saveToLocalStorage();
          this.updateWeekSelector();
          document.getElementById('weekComparison').innerHTML = '';
          alert(`Week ${selectedWeek} deleted.`);
        }
      }

      copyPlayersFromWeek() {
        const copyFromWeek = document.getElementById('copyFromWeek');
        const sourceWeek = copyFromWeek.value;
        
        if (!sourceWeek) {
          alert('Please select a week to copy from.');
          return;
        }
        
        if (!this.weeklyData[sourceWeek]) {
          alert('Selected week data not found.');
          return;
        }
        
        if (confirm(`Copy player names and coverage from ${sourceWeek} to current week? This will replace your current players.`)) {
          const sourceWeekData = this.weeklyData[sourceWeek];
          
          // Clear current players
          this.players = [];
          this.playerCounter = 1;
          
          // Copy players from source week
          sourceWeekData.players.forEach(playerData => {
            const player = {
              id: `player_${this.playerCounter++}`,
              name: playerData.name,
              startDreads: 0, // Reset to 0 for new week
              endDreads: 0,   // Reset to 0 for new week
              coverage: playerData.coverage || [] // Keep coverage settings
            };
            this.players.push(player);
          });
          
          // Re-render all players
          this.renderAllPlayers();
          this.updateUI();
          
          alert(`Copied ${this.players.length} players from ${sourceWeek}. Dread counts reset to 0.`);
        }
      }

      // Data Persistence Methods
      saveToLocalStorage() {
        const data = {
          weeklyData: this.weeklyData,
          currentWeek: this.currentWeek,
          defaultTarget: this.defaultTarget,
          lastSaved: new Date().toISOString()
        };
        localStorage.setItem('dreadCalculatorData', JSON.stringify(data));
      }

      loadSavedData() {
        try {
          const savedData = localStorage.getItem('dreadCalculatorData');
          if (savedData) {
            const data = JSON.parse(savedData);
            this.weeklyData = data.weeklyData || {};
            this.currentWeek = data.currentWeek || this.getCurrentWeek();
            this.defaultTarget = data.defaultTarget || 50;
            
            document.getElementById('defaultTarget').value = this.defaultTarget;
            this.updateWeekSelector();
            this.updateCurrentWeekDisplay();
            
            // Load current week if it exists
            if (this.weeklyData[this.currentWeek]) {
              this.loadWeekData(this.weeklyData[this.currentWeek]);
            }
          } else {
            this.updateCurrentWeekDisplay();
          }
        } catch (error) {
          console.error('Error loading saved data:', error);
          this.updateCurrentWeekDisplay();
        }
      }

      updateCurrentWeekDisplay() {
        const display = document.getElementById('currentWeekDisplay');
        if (display) {
          display.textContent = `Current Week: ${this.currentWeek}`;
        }
      }

      // Auto-save functionality
      autoSave() {
        if (this.players.length > 0) {
          this.saveToLocalStorage();
        }
      }

      // Initialize achievements system
      initializeAchievements() {
        return [
          {
            id: 'first_kill',
            title: 'First Blood',
            description: 'Kill your first dreadnought',
            icon: '‚öîÔ∏è',
            condition: (player) => (player.endDreads - player.startDreads) >= 1,
            unlocked: false
          },
          {
            id: 'target_reached',
            title: 'Target Achiever',
            description: 'Reach the weekly target',
            icon: 'üéØ',
            condition: (player) => (player.endDreads - player.startDreads) >= this.defaultTarget,
            unlocked: false
          },
          {
            id: 'perfect_week',
            title: 'Perfect Week',
            description: 'All players reach their targets',
            icon: '‚≠ê',
            condition: () => this.players.every(p => this.isPlayerComplete(p)),
            unlocked: false
          },
          {
            id: 'dread_master',
            title: 'Dread Master',
            description: 'Kill 100 dreadnoughts total',
            icon: 'üëë',
            condition: (player) => this.getPlayerTotalKills(player) >= 100,
            unlocked: false
          },
          {
            id: 'team_player',
            title: 'Team Player',
            description: 'Cover 3 different bases',
            icon: 'ü§ù',
            condition: (player) => this.getPlayerCoverageCount(player) >= 3,
            unlocked: false
          }
        ];
      }

      // Initialize milestones system
      initializeMilestones() {
        return [
          {
            id: 'total_kills_500',
            title: '500 Total Kills',
            description: 'Alliance reaches 500 total kills',
            target: 500,
            current: 0,
            icon: 'üî•'
          },
          {
            id: 'perfect_weeks_5',
            title: '5 Perfect Weeks',
            description: 'Achieve 5 perfect weeks',
            target: 5,
            current: 0,
            icon: 'üåü'
          },
          {
            id: 'active_players_20',
            title: '20 Active Players',
            description: 'Have 20 active players in a week',
            target: 20,
            current: 0,
            icon: 'üë•'
          }
        ];
      }

      // Analytics and Charts
      initializeCharts() {
        this.createWeeklyTrendChart();
        this.createPlayerComparisonChart();
        this.createCompletionRateChart();
        this.createTopPerformersChart();
      }

      createWeeklyTrendChart() {
        const ctx = document.getElementById('weeklyTrendChart');
        if (!ctx) return;

        const weeks = Object.keys(this.weeklyData).sort();
        const totalKills = weeks.map(week => {
          const weekData = this.weeklyData[week];
          return weekData.players.reduce((sum, player) => sum + (player.endDreads - player.startDreads), 0);
        });

        this.charts.weeklyTrend = new Chart(ctx, {
          type: 'line',
          data: {
            labels: weeks,
            datasets: [{
              label: 'Total Kills',
              data: totalKills,
              borderColor: '#64b5f6',
              backgroundColor: 'rgba(100, 181, 246, 0.1)',
              tension: 0.4
            }]
          },
          options: {
            responsive: true,
            plugins: {
              legend: {
                labels: { color: '#ffffff' }
              }
            },
            scales: {
              x: { ticks: { color: '#ffffff' } },
              y: { ticks: { color: '#ffffff' } }
            }
          }
        });
      }

      createPlayerComparisonChart() {
        const ctx = document.getElementById('playerComparisonChart');
        if (!ctx) return;

        const playerData = this.players.map(player => ({
          name: player.name,
          kills: player.endDreads - player.startDreads
        })).sort((a, b) => b.kills - a.kills);

        this.charts.playerComparison = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: playerData.map(p => p.name),
            datasets: [{
              label: 'Dreads Killed',
              data: playerData.map(p => p.kills),
              backgroundColor: '#10b981',
              borderColor: '#059669',
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            plugins: {
              legend: {
                labels: { color: '#ffffff' }
              }
            },
            scales: {
              x: { ticks: { color: '#ffffff' } },
              y: { ticks: { color: '#ffffff' } }
            }
          }
        });
      }

      createCompletionRateChart() {
        const ctx = document.getElementById('completionRateChart');
        if (!ctx) return;

        const weeks = Object.keys(this.weeklyData).sort();
        const completionRates = weeks.map(week => {
          const weekData = this.weeklyData[week];
          const totalPlayers = weekData.players.length;
          const completedPlayers = weekData.players.filter(p => this.isPlayerComplete(p)).length;
          return totalPlayers > 0 ? (completedPlayers / totalPlayers) * 100 : 0;
        });

        this.charts.completionRate = new Chart(ctx, {
          type: 'line',
          data: {
            labels: weeks,
            datasets: [{
              label: 'Completion Rate %',
              data: completionRates,
              borderColor: '#fbbf24',
              backgroundColor: 'rgba(251, 191, 36, 0.1)',
              tension: 0.4
            }]
          },
          options: {
            responsive: true,
            plugins: {
              legend: {
                labels: { color: '#ffffff' }
              }
            },
            scales: {
              x: { ticks: { color: '#ffffff' } },
              y: { 
                ticks: { color: '#ffffff' },
                min: 0,
                max: 100
              }
            }
          }
        });
      }

      createTopPerformersChart() {
        const ctx = document.getElementById('topPerformersChart');
        if (!ctx) return;

        // Get top 5 performers this month
        const monthlyData = this.getMonthlyTopPerformers();
        
        this.charts.topPerformers = new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels: monthlyData.map(p => p.name),
            datasets: [{
              data: monthlyData.map(p => p.kills),
              backgroundColor: [
                '#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6'
              ]
            }]
          },
          options: {
            responsive: true,
            plugins: {
              legend: {
                labels: { color: '#ffffff' }
              }
            }
          }
        });
      }

      // Player Profiles
      showPlayerProfile(playerId) {
        const player = this.players.find(p => p.id === playerId);
        if (!player) return;

        const profileDetails = document.getElementById('playerProfileDetails');
        const totalKills = this.getPlayerTotalKills(player);
        const averageKills = this.getPlayerAverageKills(player);
        const weeksActive = this.getPlayerWeeksActive(player);
        const bestWeek = this.getPlayerBestWeek(player);

        profileDetails.innerHTML = `
          <h3>${player.name} - Player Profile</h3>
          <div class="profile-stats">
            <div class="profile-stat">
              <div class="profile-stat-value">${totalKills}</div>
              <div class="profile-stat-label">Total Kills</div>
            </div>
            <div class="profile-stat">
              <div class="profile-stat-value">${averageKills.toFixed(1)}</div>
              <div class="profile-stat-label">Average/Week</div>
            </div>
            <div class="profile-stat">
              <div class="profile-stat-value">${weeksActive}</div>
              <div class="profile-stat-label">Weeks Active</div>
            </div>
            <div class="profile-stat">
              <div class="profile-stat-value">${bestWeek}</div>
              <div class="profile-stat-label">Best Week</div>
            </div>
          </div>
          <div class="player-history">
            <h4>Recent Performance</h4>
            <div id="playerHistoryChart"></div>
          </div>
        `;
        profileDetails.style.display = 'block';
      }

      // Custom Goals & Targets
      addCustomTarget() {
        const playerName = prompt('Enter player name for custom target:');
        if (!playerName) return;

        const target = parseInt(prompt('Enter custom target for ' + playerName + ':'));
        if (isNaN(target)) return;

        this.customTargets[playerName] = target;
        this.updateCustomTargetsList();
        this.saveToLocalStorage();
      }

      updateCustomTargetsList() {
        const container = document.getElementById('customTargetsList');
        if (!container) return;
        container.innerHTML = '';

        Object.entries(this.customTargets).forEach(([playerName, target]) => {
          const item = document.createElement('div');
          item.className = 'custom-target-item';
          item.innerHTML = `
            <span>${playerName}:</span>
            <input type="number" value="${target}" onchange="dreadCalculator.updateCustomTarget('${playerName}', this.value)">
            <button onclick="dreadCalculator.removeCustomTarget('${playerName}')" class="remove-player-btn">Remove</button>
          `;
          container.appendChild(item);
        });
      }

      updateCustomTarget(playerName, newTarget) {
        this.customTargets[playerName] = parseInt(newTarget);
        this.saveToLocalStorage();
      }

      removeCustomTarget(playerName) {
        delete this.customTargets[playerName];
        this.updateCustomTargetsList();
        this.saveToLocalStorage();
      }

      setTeamGoal(goal) {
        this.teamGoal = parseInt(goal) || 0;
        this.updateTeamGoalProgress();
        this.saveToLocalStorage();
      }

      updateTeamGoalProgress() {
        const currentTotal = this.players.reduce((sum, player) => sum + (player.endDreads - player.startDreads), 0);
        const progress = this.teamGoal > 0 ? (currentTotal / this.teamGoal) * 100 : 0;
        const progressElement = document.getElementById('teamGoalProgress');
        if (progressElement) {
          progressElement.textContent = `${Math.min(progress, 100).toFixed(1)}%`;
        }
      }

      // Notifications
      toggleNotification(type, enabled) {
        this.notificationSettings[type] = enabled;
        this.saveToLocalStorage();
        
        if (enabled && type === 'weekly') {
          this.scheduleWeeklyReminder();
        }
      }

      testNotification() {
        if ('Notification' in window) {
          if (Notification.permission === 'granted') {
            new Notification('Dread Calculator Test', {
              body: 'This is a test notification from your Dread Calculator!',
              icon: '/icons/icon-192x192.png'
            });
          } else if (Notification.permission !== 'denied') {
            Notification.requestPermission().then(permission => {
              if (permission === 'granted') {
                this.testNotification();
              }
            });
          }
        }
      }

      scheduleWeeklyReminder() {
        // Schedule weekly reminder for Friday evening
        const now = new Date();
        const friday = new Date(now);
        friday.setDate(now.getDate() + (5 - now.getDay() + 7) % 7);
        friday.setHours(18, 0, 0, 0);

        if (friday <= now) {
          friday.setDate(friday.getDate() + 7);
        }

        const timeUntilReminder = friday.getTime() - now.getTime();
        setTimeout(() => {
          this.sendWeeklyReminder();
          this.scheduleWeeklyReminder(); // Schedule next week
        }, timeUntilReminder);
      }

      sendWeeklyReminder() {
        if (this.notificationSettings.weekly && 'Notification' in window && Notification.permission === 'granted') {
          new Notification('Weekly Dread Update Reminder', {
            body: 'Don\'t forget to update your dreadnought kills for this week!',
            icon: '/icons/icon-192x192.png'
          });
        }
      }

      // Cloud Backup & Sync
      backupToCloud() {
        const data = {
          players: this.players,
          weeklyData: this.weeklyData,
          customTargets: this.customTargets,
          teamGoal: this.teamGoal,
          achievements: this.achievements,
          timestamp: new Date().toISOString()
        };

        // Simulate cloud backup (in real implementation, this would use a cloud service)
        this.cloudData = data;
        this.lastBackupTime = new Date().toLocaleString();
        this.updateBackupStatus();
        
        // Show success message
        alert('Data backed up to cloud successfully!');
      }

      restoreFromCloud() {
        if (!this.cloudData) {
          alert('No cloud backup found!');
          return;
        }

        if (confirm('This will overwrite your current data. Continue?')) {
          this.players = this.cloudData.players || [];
          this.weeklyData = this.cloudData.weeklyData || {};
          this.customTargets = this.cloudData.customTargets || {};
          this.teamGoal = this.cloudData.teamGoal || 0;
          this.achievements = this.cloudData.achievements || [];
          
          this.updateUI();
          this.saveToLocalStorage();
          alert('Data restored from cloud successfully!');
        }
      }

      syncData() {
        // Simulate data sync
        this.syncStatus = 'Synced';
        this.updateBackupStatus();
        alert('Data synced successfully!');
      }

      updateBackupStatus() {
        const lastBackupElement = document.getElementById('lastBackupTime');
        const syncStatusElement = document.getElementById('syncStatus');
        if (lastBackupElement) {
          lastBackupElement.textContent = this.lastBackupTime || 'Never';
        }
        if (syncStatusElement) {
          syncStatusElement.textContent = this.syncStatus;
        }
      }

      // Voice Input
      startVoiceInput() {
        if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
          alert('Voice input not supported in this browser');
          return;
        }

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        this.voiceRecognition = new SpeechRecognition();
        
        this.voiceRecognition.continuous = true;
        this.voiceRecognition.interimResults = true;
        this.voiceRecognition.lang = 'en-US';

        this.voiceRecognition.onstart = () => {
          this.isRecording = true;
          const voiceStatus = document.getElementById('voiceStatus');
          const voiceInputBtn = document.getElementById('voiceInputBtn');
          const stopVoiceBtn = document.getElementById('stopVoiceBtn');
          
          if (voiceStatus) voiceStatus.textContent = 'Listening... Speak now!';
          if (voiceInputBtn) voiceInputBtn.style.display = 'none';
          if (stopVoiceBtn) stopVoiceBtn.style.display = 'inline-block';
          if (voiceStatus) voiceStatus.classList.add('voice-recording');
        };

        this.voiceRecognition.onresult = (event) => {
          let finalTranscript = '';
          for (let i = event.resultIndex; i < event.results.length; i++) {
            if (event.results[i].isFinal) {
              finalTranscript += event.results[i][0].transcript;
            }
          }
          
          if (finalTranscript) {
            this.processVoiceInput(finalTranscript);
          }
        };

        this.voiceRecognition.onerror = (event) => {
          console.error('Speech recognition error:', event.error);
          this.stopVoiceInput();
        };

        this.voiceRecognition.start();
      }

      stopVoiceInput() {
        if (this.voiceRecognition) {
          this.voiceRecognition.stop();
        }
        this.isRecording = false;
        const voiceStatus = document.getElementById('voiceStatus');
        const voiceInputBtn = document.getElementById('voiceInputBtn');
        const stopVoiceBtn = document.getElementById('stopVoiceBtn');
        
        if (voiceStatus) voiceStatus.textContent = 'Voice input stopped';
        if (voiceInputBtn) voiceInputBtn.style.display = 'inline-block';
        if (stopVoiceBtn) stopVoiceBtn.style.display = 'none';
        if (voiceStatus) voiceStatus.classList.remove('voice-recording');
      }

      processVoiceInput(transcript) {
        const results = document.getElementById('voiceResults');
        if (!results) return;
        
        results.innerHTML += `<p>Heard: "${transcript}"</p>`;
        
        // Simple voice command processing
        const lowerTranscript = transcript.toLowerCase();
        
        if (lowerTranscript.includes('add player')) {
          this.addPlayer();
          results.innerHTML += '<p>‚úÖ Added new player</p>';
        } else if (lowerTranscript.includes('clear all')) {
          this.clearAllPlayers();
          results.innerHTML += '<p>‚úÖ Cleared all players</p>';
        } else if (lowerTranscript.includes('save week')) {
          this.saveCurrentWeek();
          results.innerHTML += '<p>‚úÖ Saved current week</p>';
        }
        
        // Auto-scroll to bottom
        results.scrollTop = results.scrollHeight;
      }

      // Helper methods for analytics
      getPlayerTotalKills(player) {
        return this.players.reduce((total, p) => {
          if (p.name === player.name) {
            return total + (p.endDreads - p.startDreads);
          }
          return total;
        }, 0);
      }

      getPlayerAverageKills(player) {
        const weeks = Object.values(this.weeklyData);
        const playerWeeks = weeks.filter(week => week.players.some(p => p.name === player.name));
        if (playerWeeks.length === 0) return 0;
        
        const totalKills = playerWeeks.reduce((sum, week) => {
          const weekPlayer = week.players.find(p => p.name === player.name);
          return sum + (weekPlayer ? (weekPlayer.endDreads - weekPlayer.startDreads) : 0);
        }, 0);
        
        return totalKills / playerWeeks.length;
      }

      getPlayerWeeksActive(player) {
        const weeks = Object.values(this.weeklyData);
        return weeks.filter(week => week.players.some(p => p.name === player.name)).length;
      }

      getPlayerBestWeek(player) {
        const weeks = Object.values(this.weeklyData);
        let bestKills = 0;
        
        weeks.forEach(week => {
          const weekPlayer = week.players.find(p => p.name === player.name);
          if (weekPlayer) {
            const kills = weekPlayer.endDreads - weekPlayer.startDreads;
            bestKills = Math.max(bestKills, kills);
          }
        });
        
        return bestKills;
      }

      getPlayerCoverageCount(player) {
        return this.players.filter(p => p.coverage && p.coverage.includes(player.name)).length;
      }

      getMonthlyTopPerformers() {
        const currentMonth = new Date().getMonth();
        const currentYear = new Date().getFullYear();
        
        const monthlyData = {};
        
        Object.values(this.weeklyData).forEach(week => {
          const weekDate = new Date(week.timestamp);
          if (weekDate.getMonth() === currentMonth && weekDate.getFullYear() === currentYear) {
            week.players.forEach(player => {
              if (!monthlyData[player.name]) {
                monthlyData[player.name] = 0;
              }
              monthlyData[player.name] += (player.endDreads - player.startDreads);
            });
          }
        });
        
        return Object.entries(monthlyData)
          .map(([name, kills]) => ({ name, kills }))
          .sort((a, b) => b.kills - a.kills)
          .slice(0, 5);
      }

      // PDF Export
      exportPdf() {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        
        // Title
        doc.setFontSize(20);
        doc.text('Alliance Dread Calculator Report', 20, 20);
        
        // Current week info
        doc.setFontSize(12);
        doc.text(`Report Generated: ${new Date().toLocaleDateString()}`, 20, 35);
        doc.text(`Current Week: ${this.currentWeek}`, 20, 45);
        
        let yPosition = 60;
        
        // Summary statistics
        doc.setFontSize(16);
        doc.text('Summary Statistics', 20, yPosition);
        yPosition += 15;
        
        const totalPlayers = this.players.length;
        const totalKills = this.players.reduce((sum, player) => sum + (player.endDreads - player.startDreads), 0);
        const averageKills = totalPlayers > 0 ? (totalKills / totalPlayers).toFixed(1) : 0;
        const completedPlayers = this.players.filter(p => this.isPlayerComplete(p)).length;
        
        doc.setFontSize(10);
        doc.text(`Total Players: ${totalPlayers}`, 20, yPosition);
        yPosition += 10;
        doc.text(`Total Dreads Killed: ${totalKills}`, 20, yPosition);
        yPosition += 10;
        doc.text(`Average per Player: ${averageKills}`, 20, yPosition);
        yPosition += 10;
        doc.text(`Players Completed Target: ${completedPlayers}/${totalPlayers}`, 20, yPosition);
        yPosition += 20;
        
        // Player details
        doc.setFontSize(16);
        doc.text('Player Details', 20, yPosition);
        yPosition += 15;
        
        doc.setFontSize(8);
        this.players.forEach((player, index) => {
          if (yPosition > 280) {
            doc.addPage();
            yPosition = 20;
          }
          
          const kills = player.endDreads - player.startDreads;
          const isComplete = this.isPlayerComplete(player) ? '‚úì' : '‚úó';
          
          doc.text(`${index + 1}. ${player.name}`, 20, yPosition);
          doc.text(`   Kills: ${kills} (${player.startDreads} ‚Üí ${player.endDreads})`, 25, yPosition + 5);
          doc.text(`   Target Reached: ${isComplete}`, 25, yPosition + 10);
          
          if (player.coverage) {
            doc.text(`   Coverage: ${player.coverage}`, 25, yPosition + 15);
            yPosition += 20;
          } else {
            yPosition += 15;
          }
        });
        
        // Weekly history if enabled
        const includeHistory = document.getElementById('includeHistory')?.checked;
        if (includeHistory && Object.keys(this.weeklyData).length > 0) {
          if (yPosition > 250) {
            doc.addPage();
            yPosition = 20;
          }
          
          doc.setFontSize(16);
          doc.text('Weekly History', 20, yPosition);
          yPosition += 15;
          
          doc.setFontSize(8);
          Object.entries(this.weeklyData).forEach(([week, data]) => {
            if (yPosition > 280) {
              doc.addPage();
              yPosition = 20;
            }
            
            doc.text(`Week ${week}:`, 20, yPosition);
            yPosition += 8;
            
            const weekTotal = data.players.reduce((sum, p) => sum + (p.endDreads - p.startDreads), 0);
            doc.text(`  Total Kills: ${weekTotal}`, 25, yPosition);
            yPosition += 8;
            doc.text(`  Players: ${data.players.length}`, 25, yPosition);
            yPosition += 12;
          });
        }
        
        // Save the PDF
        doc.save(`dread-calculator-report-${this.currentWeek}.pdf`);
      }

      // Excel Export
      exportExcel() {
        const workbook = XLSX.utils.book_new();
        
        // Current week data
        const currentWeekData = this.players.map(player => ({
          'Player Name': player.name,
          'Start Dreads': player.startDreads,
          'End Dreads': player.endDreads,
          'Dreads Killed': player.endDreads - player.startDreads,
          'Target Reached': this.isPlayerComplete(player) ? 'Yes' : 'No',
          'Coverage': player.coverage || 'None'
        }));
        
        const currentWeekSheet = XLSX.utils.json_to_sheet(currentWeekData);
        XLSX.utils.book_append_sheet(workbook, currentWeekSheet, 'Current Week');
        
        // Summary sheet
        const totalPlayers = this.players.length;
        const totalKills = this.players.reduce((sum, player) => sum + (player.endDreads - player.startDreads), 0);
        const averageKills = totalPlayers > 0 ? (totalKills / totalPlayers).toFixed(1) : 0;
        const completedPlayers = this.players.filter(p => this.isPlayerComplete(p)).length;
        
        const summaryData = [
          ['Metric', 'Value'],
          ['Total Players', totalPlayers],
          ['Total Dreads Killed', totalKills],
          ['Average per Player', averageKills],
          ['Players Completed Target', completedPlayers],
          ['Completion Rate', totalPlayers > 0 ? `${((completedPlayers / totalPlayers) * 100).toFixed(1)}%` : '0%'],
          ['Current Week', this.currentWeek],
          ['Report Date', new Date().toLocaleDateString()]
        ];
        
        const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
        XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');
        
        // Weekly history if enabled
        const includeHistory = document.getElementById('includeHistory')?.checked;
        if (includeHistory && Object.keys(this.weeklyData).length > 0) {
          const historyData = [];
          
          Object.entries(this.weeklyData).forEach(([week, data]) => {
            const weekTotal = data.players.reduce((sum, p) => sum + (p.endDreads - p.startDreads), 0);
            const weekCompleted = data.players.filter(p => this.isPlayerComplete(p)).length;
            
            historyData.push({
              'Week': week,
              'Total Players': data.players.length,
              'Total Kills': weekTotal,
              'Average per Player': data.players.length > 0 ? (weekTotal / data.players.length).toFixed(1) : 0,
              'Players Completed': weekCompleted,
              'Completion Rate': data.players.length > 0 ? `${((weekCompleted / data.players.length) * 100).toFixed(1)}%` : '0%'
            });
          });
          
          const historySheet = XLSX.utils.json_to_sheet(historyData);
          XLSX.utils.book_append_sheet(workbook, historySheet, 'Weekly History');
        }
        
        // Player performance over time
        if (Object.keys(this.weeklyData).length > 0) {
          const performanceData = [];
          const allPlayerNames = new Set();
          
          // Collect all unique player names
          Object.values(this.weeklyData).forEach(week => {
            week.players.forEach(player => allPlayerNames.add(player.name));
          });
          
          // Create performance matrix
          allPlayerNames.forEach(playerName => {
            const playerRow = { 'Player': playerName };
            
            Object.entries(this.weeklyData).forEach(([week, data]) => {
              const player = data.players.find(p => p.name === playerName);
              playerRow[`Week ${week}`] = player ? (player.endDreads - player.startDreads) : 0;
            });
            
            performanceData.push(playerRow);
          });
          
          const performanceSheet = XLSX.utils.json_to_sheet(performanceData);
          XLSX.utils.book_append_sheet(workbook, performanceSheet, 'Player Performance');
        }
        
        // Save the Excel file
        XLSX.writeFile(workbook, `dread-calculator-${this.currentWeek}.xlsx`);
      }
    }

    // Initialize the calculator
    let dreadCalculator;
    let themeManager;
    let gestureManager;

    // Initialize everything when the page loads
    window.addEventListener('load', () => {
      dreadCalculator = new DreadCalculator();
      themeManager = new ThemeManager();
      gestureManager = new GestureManager();
      dreadCalculator.loadSavedData();
      dreadCalculator.updateCurrentWeekDisplay();
      dreadCalculator.initializeCharts();
      dreadCalculator.updateCustomTargetsList();
      dreadCalculator.updateBackupStatus();
    });

    // Theme and Accessibility Management
    class ThemeManager {
      constructor() {
        this.currentTheme = localStorage.getItem('theme') || 'dark';
        this.accessibilitySettings = JSON.parse(localStorage.getItem('accessibility') || '{}');
        this.init();
      }

      init() {
        this.applyTheme(this.currentTheme);
        this.bindEvents();
        this.applyAccessibilitySettings();
      }

      bindEvents() {
        // Theme toggle
        document.getElementById('themeToggle').addEventListener('click', () => {
          this.toggleTheme();
        });

        // Color scheme selector
        document.getElementById('colorScheme').addEventListener('change', (e) => {
          this.setTheme(e.target.value);
        });

        // Accessibility toggle
        document.getElementById('accessibilityToggle').addEventListener('click', () => {
          this.toggleAccessibilityPanel();
        });

        // Close accessibility panel
        document.getElementById('closeAccessibilityPanel').addEventListener('click', () => {
          this.closeAccessibilityPanel();
        });

        // Accessibility options
        document.getElementById('highContrast').addEventListener('change', (e) => {
          this.setAccessibilityOption('highContrast', e.target.checked);
        });

        document.getElementById('largeText').addEventListener('change', (e) => {
          this.setAccessibilityOption('largeText', e.target.checked);
        });

        document.getElementById('reduceMotion').addEventListener('change', (e) => {
          this.setAccessibilityOption('reduceMotion', e.target.checked);
        });

        document.getElementById('hapticFeedback').addEventListener('change', (e) => {
          this.setAccessibilityOption('hapticFeedback', e.target.checked);
        });

        document.getElementById('switchControl').addEventListener('change', (e) => {
          this.setAccessibilityOption('switchControl', e.target.checked);
        });

        document.getElementById('screenReader').addEventListener('change', (e) => {
          this.setAccessibilityOption('screenReader', e.target.checked);
        });

        // Font scaling
        document.getElementById('fontScale').addEventListener('input', (e) => {
          this.setFontScale(parseFloat(e.target.value));
        });
      }

      toggleTheme() {
        const themes = ['dark', 'light', 'blue', 'green'];
        const currentIndex = themes.indexOf(this.currentTheme);
        const nextIndex = (currentIndex + 1) % themes.length;
        this.setTheme(themes[nextIndex]);
      }

      setTheme(theme) {
        this.currentTheme = theme;
        document.documentElement.setAttribute('data-theme', theme);
        localStorage.setItem('theme', theme);
        
        // Update UI
        document.getElementById('colorScheme').value = theme;
        const themeToggle = document.getElementById('themeToggle');
        const themeIcons = { dark: 'üåô', light: '‚òÄÔ∏è', blue: 'üîµ', green: 'üü¢' };
        themeToggle.innerHTML = `${themeIcons[theme]} ${theme.charAt(0).toUpperCase() + theme.slice(1)}`;
        
        this.triggerHaptic('light');
      }

      applyTheme(theme) {
        document.documentElement.setAttribute('data-theme', theme);
        document.getElementById('colorScheme').value = theme;
        const themeToggle = document.getElementById('themeToggle');
        const themeIcons = { dark: 'üåô', light: '‚òÄÔ∏è', blue: 'üîµ', green: 'üü¢' };
        themeToggle.innerHTML = `${themeIcons[theme]} ${theme.charAt(0).toUpperCase() + theme.slice(1)}`;
      }

      toggleAccessibilityPanel() {
        const panel = document.getElementById('accessibilityPanel');
        panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        this.triggerHaptic('light');
      }

      closeAccessibilityPanel() {
        const panel = document.getElementById('accessibilityPanel');
        panel.style.display = 'none';
        this.triggerHaptic('light');
      }

      setAccessibilityOption(option, value) {
        this.accessibilitySettings[option] = value;
        localStorage.setItem('accessibility', JSON.stringify(this.accessibilitySettings));
        this.applyAccessibilitySettings();
        this.triggerHaptic('light');
      }

      applyAccessibilitySettings() {
        const body = document.body;
        
        // High contrast
        if (this.accessibilitySettings.highContrast) {
          body.classList.add('high-contrast');
        } else {
          body.classList.remove('high-contrast');
        }

        // Large text
        if (this.accessibilitySettings.largeText) {
          body.classList.add('large-text');
        } else {
          body.classList.remove('large-text');
        }

        // Reduce motion
        if (this.accessibilitySettings.reduceMotion) {
          body.classList.add('reduce-motion');
        } else {
          body.classList.remove('reduce-motion');
        }

        // Switch control support
        if (this.accessibilitySettings.switchControl) {
          body.classList.add('switch-control');
          this.enhanceKeyboardNavigation();
        } else {
          body.classList.remove('switch-control');
        }

        // Screen reader support
        if (this.accessibilitySettings.screenReader) {
          this.enhanceScreenReaderSupport();
        }

        // Update checkboxes
        Object.keys(this.accessibilitySettings).forEach(key => {
          const checkbox = document.getElementById(key);
          if (checkbox) {
            checkbox.checked = this.accessibilitySettings[key];
          }
        });

        // Apply font scale
        const fontScale = this.accessibilitySettings.fontScale || 1.0;
        this.setFontScale(fontScale);
      }

      setFontScale(scale) {
        this.accessibilitySettings.fontScale = scale;
        localStorage.setItem('accessibility', JSON.stringify(this.accessibilitySettings));
        
        // Remove existing font scale classes
        document.body.classList.remove(...Object.keys(this.accessibilitySettings)
          .filter(key => key.startsWith('font-scale-'))
          .map(key => key.replace('font-scale-', 'font-scale-')));
        
        // Apply new font scale
        const scaleClass = `font-scale-${Math.round(scale * 100)}`;
        document.body.classList.add(scaleClass);
        
        // Update font scale display
        const fontScaleValue = document.getElementById('fontScaleValue');
        if (fontScaleValue) {
          fontScaleValue.textContent = `${Math.round(scale * 100)}%`;
        }
        
        // Update font scale slider
        const fontScaleSlider = document.getElementById('fontScale');
        if (fontScaleSlider) {
          fontScaleSlider.value = scale;
        }
        
        this.triggerHaptic('light');
      }

      enhanceKeyboardNavigation() {
        // Add keyboard navigation enhancements
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Tab') {
            // Enhanced tab navigation
            const focusableElements = document.querySelectorAll(
              'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            );
            
            if (e.shiftKey) {
              // Shift + Tab - go backwards
              if (document.activeElement === focusableElements[0]) {
                focusableElements[focusableElements.length - 1].focus();
                e.preventDefault();
              }
            } else {
              // Tab - go forwards
              if (document.activeElement === focusableElements[focusableElements.length - 1]) {
                focusableElements[0].focus();
                e.preventDefault();
              }
            }
          }
          
          // Space and Enter key handling for buttons
          if ((e.key === ' ' || e.key === 'Enter') && e.target.tagName === 'BUTTON') {
            e.target.click();
            e.preventDefault();
          }
        });
      }

      enhanceScreenReaderSupport() {
        // Add ARIA labels and descriptions
        const buttons = document.querySelectorAll('button:not([aria-label])');
        buttons.forEach(button => {
          if (!button.getAttribute('aria-label')) {
            button.setAttribute('aria-label', button.textContent.trim() || 'Button');
          }
        });

        const inputs = document.querySelectorAll('input:not([aria-label])');
        inputs.forEach(input => {
          if (!input.getAttribute('aria-label')) {
            const label = document.querySelector(`label[for="${input.id}"]`);
            if (label) {
              input.setAttribute('aria-label', label.textContent.trim());
            }
          }
        });

        // Add live regions for dynamic content
        if (!document.getElementById('live-region')) {
          const liveRegion = document.createElement('div');
          liveRegion.id = 'live-region';
          liveRegion.setAttribute('aria-live', 'polite');
          liveRegion.setAttribute('aria-atomic', 'true');
          liveRegion.className = 'sr-only';
          document.body.appendChild(liveRegion);
        }
      }

      announceToScreenReader(message) {
        const liveRegion = document.getElementById('live-region');
        if (liveRegion && this.accessibilitySettings.screenReader) {
          liveRegion.textContent = message;
          setTimeout(() => {
            liveRegion.textContent = '';
          }, 1000);
        }
      }

      triggerHaptic(type = 'light') {
        if (!this.accessibilitySettings.hapticFeedback) return;
        
        if ('vibrate' in navigator) {
          const patterns = {
            light: [10],
            medium: [20],
            heavy: [50],
            success: [10, 50, 10],
            error: [100, 50, 100]
          };
          navigator.vibrate(patterns[type] || patterns.light);
        }
      }
    }

    // Gesture Navigation
    class GestureManager {
      constructor() {
        this.touchStartX = 0;
        this.touchStartY = 0;
        this.touchEndX = 0;
        this.touchEndY = 0;
        this.minSwipeDistance = 50;
        this.init();
      }

      init() {
        document.addEventListener('touchstart', (e) => {
          this.touchStartX = e.changedTouches[0].screenX;
          this.touchStartY = e.changedTouches[0].screenY;
        });

        document.addEventListener('touchend', (e) => {
          this.touchEndX = e.changedTouches[0].screenX;
          this.touchEndY = e.changedTouches[0].screenY;
          this.handleSwipe();
        });
      }

      handleSwipe() {
        const deltaX = this.touchEndX - this.touchStartX;
        const deltaY = this.touchEndY - this.touchStartY;
        const absDeltaX = Math.abs(deltaX);
        const absDeltaY = Math.abs(deltaY);

        if (absDeltaX > this.minSwipeDistance && absDeltaX > absDeltaY) {
          if (deltaX > 0) {
            this.handleSwipeRight();
          } else {
            this.handleSwipeLeft();
          }
        } else if (absDeltaY > this.minSwipeDistance && absDeltaY > absDeltaX) {
          if (deltaY > 0) {
            this.handleSwipeDown();
          } else {
            this.handleSwipeUp();
          }
        }
      }

      handleSwipeLeft() {
        // Swipe left - could navigate to next section
        themeManager.triggerHaptic('light');
      }

      handleSwipeRight() {
        // Swipe right - could navigate to previous section
        themeManager.triggerHaptic('light');
      }

      handleSwipeUp() {
        // Swipe up - could show history
        if (dreadCalculator) {
          dreadCalculator.toggleHistoryView();
          themeManager.triggerHaptic('light');
        }
      }

      handleSwipeDown() {
        // Swipe down - could hide panels
        const panel = document.getElementById('accessibilityPanel');
        if (panel.style.display === 'block') {
          panel.style.display = 'none';
          themeManager.triggerHaptic('light');
        }
      }
    }

    // Initialize managers
    const themeManager = new ThemeManager();
    const gestureManager = new GestureManager();

    // PWA Installation and Service Worker
    let deferredPrompt;
    let isInstalled = false;

    // Check if app is already installed
    if (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true) {
      isInstalled = true;
      console.log('PWA is already installed');
    }

    // Service Worker registration
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./sw.js', { scope: './' }).then(registration => {
        console.log('SW registered: ', registration);
        
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              if (confirm('New version available! Reload to update?')) {
                newWorker.postMessage({ type: 'SKIP_WAITING' });
                window.location.reload();
              }
            }
          });
        });
      })
      .catch(registrationError => {
        console.log('SW registration failed: ', registrationError);
      });
    }

    // PWA Install prompt
    window.addEventListener('beforeinstallprompt', (e) => {
      console.log('PWA install prompt triggered');
      e.preventDefault();
      deferredPrompt = e;
      
      // Show install button if not already installed
      if (!isInstalled) {
        showInstallButton();
      }
    });

    // Handle successful installation
    window.addEventListener('appinstalled', (evt) => {
      console.log('PWA was installed');
      isInstalled = true;
      hideInstallButton();
      deferredPrompt = null;
    });

    function showInstallButton() {
      // Create install button
      const installBtn = document.createElement('button');
      installBtn.id = 'installBtn';
      installBtn.innerHTML = 'üì± Install App';
      installBtn.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #10b981 !important;
        color: white !important;
        border: 2px solid #059669 !important;
        padding: 12px 20px;
        border-radius: 8px;
        font-weight: bold;
        cursor: pointer;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        font-size: 14px;
        min-height: 44px;
        transition: all 0.3s ease;
      `;
      
      installBtn.addEventListener('click', async () => {
        if (deferredPrompt) {
          deferredPrompt.prompt();
          const { outcome } = await deferredPrompt.userChoice;
          console.log(`User response to the install prompt: ${outcome}`);
          deferredPrompt = null;
          hideInstallButton();
        }
      });
      
      document.body.appendChild(installBtn);
    }

    function hideInstallButton() {
      const installBtn = document.getElementById('installBtn');
      if (installBtn) {
        installBtn.remove();
      }
    }

    // Handle URL shortcuts
    const urlParams = new URLSearchParams(window.location.search);
    const action = urlParams.get('action');
    
    if (action === 'new-week') {
      setTimeout(() => {
        if (dreadCalculator) {
          dreadCalculator.startNewWeek();
        }
      }, 1000);
    } else if (action === 'history') {
      setTimeout(() => {
        if (dreadCalculator) {
          dreadCalculator.toggleHistoryView();
        }
      }, 1000);
    }

    // Prevent zoom on mobile
    document.addEventListener('gesturestart', function (e) {
      e.preventDefault();
    });

    // Handle orientation change
    window.addEventListener('orientationchange', function() {
      setTimeout(() => {
        window.scrollTo(0, 0);
      }, 100);
    });
  </script>
</body>
</html>
